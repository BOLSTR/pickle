h1. Pickle

Stick this in vendor/plugins to have cucumber steps that create your models easily from factory_girl/machinist/active_record

References to the models are stored, not for the purpose of checking the db (although you could use it for
that), but for enabling easy reference to urls, and for building complex givens which require a bunch of
models collaborating

h2. Install

Install pickle either as a rails plugin, or a gem

<pre>
	# plugin
	script/plugin install git://github.com/ianwhite/pickle.git # or add it as a submodule
	
	# or, gem
	sudo gem install ianwhite-pickle
</pre>
  
h2. Get Started

(you'd better install cucumber)

<pre>
	script/generate pickle
</pre>

Now have a look at features/step_definitions/pickle_steps.rb

h3. Using with plain ole Active Record

If you have an AR called 'Post', with required fields 'title', and 'body', then you can now write 
steps like this

<pre>
  Given a post exists with title: "My Post", body: "My body"
</pre>

h3. Using with a factory!

But you're using Machinist or FactoryGirl right?!  So to leverage all of the factories/blueprints
you've written, you can just do stuff like

<pre>
	Given a user exists
	And another user exists with role: "admin"
	
	# later
	Then a user should exist with name: "Fred"
	And that user should be activated # this uses rspec predicate matchers
</pre>

h3. Using with Machinist

In your features/support/env.rb add the following lines at the bottom

<pre>
  require "#{Rails.root}/spec/blueprints" # or wherever they live
  Before { Sham.rest } # reset Shams in between scenarios
</pre>

h3. Referring to models, using models as field values

You might want to set up a scenario with several models of the same type.
You can label your models for easy reference.  The following example requires
a post and complaint blueprint (or factory), and requires writing no 
additional steps.

<pre>
	Given a post: "spam" exists with spam: "true"
	And a post: "sane" exists
	And a complaint exists with complaint_regarding: post "spam"
	And a complaint exists with complaint_regarding: post "sane"
</pre>

h3. Configuring Pickle

Pickle needs to be configured before steps are defined, so to change
pickle's default config you must specify the config *before* the @require 'pickle'@ 
command in features/support/env.rb

<pre>
	# example config
	require 'pickle/config'
	
	Pickle.configure do |config|
	  config.adapters = [:machinist, YourOwnAdapterClass]
	  config.map 'me', 'myself', 'my', 'I', :to => 'user: "me"'
  end

  # load up pickle
  require 'pickle'
</pre>

h2. API

h3. Regexps for us in your own steps

For capturing english versions of model names you get 

  *CaptureModel*

<pre>
  Given /^#{CaptureModel} exists$/ do |model_name|
    model(model_name).should_not == nil
  end

  Then /^I should be at the (.*?) page$/ |page|
  if page =~ /#{CaptureModel}'s/
    url_for(model($1))
  else
    # ...
  end
  end
</pre>

For capturing a field string, you get

*CaptureFields*
  
<pre>
  Given /^#{CaptureModel} exists with #{CaptureFields}$/ do |model_name, fields|
    create_model(model_name, fields)
  end
</pre>
Take a look at features/step_definitions/pickle_steps.rb for more examples

h3. Creating and tracking models

h4. create_model(_model_name_[, _field_string_])

This will create a model using the factory name, and optional model label, with the field_string provided.  The created model can be later referred to via its name.

For example:

<pre>
  create_model 'a user'         					# => will create a User
  create_model 'the user: "1"'      			# => will create a User, enabling later reference to it with 'user: "1"'
  create_model 'the user', 'name: "Fred"'	# => will create a User with attributes {:name => "Fred"}
</pre>

If you don't use Machinist or FactoryGirl, you can still create models, but you must pass in all the fields required to make them valid.

However, if you do use Machinist or FactoryGirl, then just use the factory or blueprint name, and will be super sweet.

h4. find_model(_model_name_, _field_string_)

This will find a model of the passed class matching the passed field string.  The found model can be later referred to by its name.

For example:

<pre>
  find_model('a user', 'name: "Fred'")		# => find a user matching those attributes
</pre>

h4. model(_model_name_) 

Refers to a model that has already been created/found (ie. referred to in a scenario)

For example:

<pre>
  create_model('a user')
  model('the user') # => refers to above user
  model('a user')   # => refers to above user

  create_model('a car: "herbie"')  		# => herbie
  create_model('a car: "batmobile"')	# => the batmobile
  model('the first car') 		# => herbie
  model('the 2nd car') 			# => batmobile
  model('the car "herbie")	# => herbie
</pre>

h4. created_model(_model_name_)

*model* always pulls from the db to get a fresh copy.  If you need to access the originally created object for some reason (perhaps it has a one-time key on it that is used in a mailer for example), you can retreive it with *created_model*

h4. more [TODO]