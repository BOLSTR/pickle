# this file generated by script/generate pickle page

When(/^I go to \/(.+?)$/) do |path|
  visit "/#{path}"
end

Then(/^I should be at \/(.+?)$/) do |path|
  request.path.should =~ /^\/#{path}/
end

When(/^I go to (.+?) page$/) do |page|
  visit page_to_path(page)
end

Then(/^I should be at (.+?) page$/) do |page|
  request.path.should =~ /^#{page_to_path(page)}/
end

# passed a string like 'the home', returns a path
def page_to_path(page)
  case page
  
  # add your own app-specific mappings, e.g.
  #
  # when 'the home'
  #   '/'
  #
  # when /$#{capture_model}'s activation^/
  #   activation_by_code_path(created_model($1).activation_code)
    
  when /^#{capture_model}'s$/                     # the user: "fred"'s  
    find_path_for [model($1)]
    
  when /^#{capture_model}'s #{capture_model}'s$/  # the user's post's
    find_path_for [model($1), model($2)]

  when /^#{capture_model}'s (.*?)$/               # the post's comments
    find_path_for [model($1)], $2

  when /^the (.+?)$/            # the new session # => new_session_path
    send "#{$1.downcase.gsub(' ','_')}_path"
    
  else
    raise "Could not map '#{page}' to a path"
  end
end

# given a array of models, and an optional segment, will attempt to find a matching named route
def find_path_for(models, segment = nil)
  model_names = models.map{|m| m.class.name.underscore}.join("_")
  unless segment
    return send("#{model_names}_path", *models)
  else
    segment = segment.underscore.gsub(' ','_')
    path = (send("#{model_names}_#{segment}_path", *models) rescue nil) and return path
    path = (send("#{segment}_#{model_names}_path", *models) rescue nil) and return path
    # try splitting up the segment
    if (segments = segment.split('_')).length > 1
      action, segment = segments[0], segments[1..-1].join('_')
      path = (send("#{action}_#{model_names}_#{segment}_path", *models) rescue nil) and return path
    end
  end
  raise "Could not figure out a path for '#{model_names}' and '#{segment}'"
end